1.redis支持的数据类型
String字符串：
格式: set key value
string类型是二进制安全的。意思是redis的string可以包含任何数据。比如jpg图片或者序列化的对象 。
string类型是Redis最基本的数据类型，一个键最大能存储512MB。

Hash（哈希）
格式: hmset name  key1 value1 key2 value2
Redis hash 是一个键值(key=>value)对集合。
Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。

List（列表）
Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）
格式: lpush  name  value
在 key 对应 list 的头部添加字符串元素
格式: rpush  name  value
在 key 对应 list 的尾部添加字符串元素
格式: lrem name  index
key 对应 list 中删除 count 个和 value 相同的元素
格式: llen name
返回 key 对应 list 的长度

Set（集合）
格式: sadd  name  value
Redis的Set是string类型的无序集合。
集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。

zset(sorted set：有序集合)
格式: zadd  name score value
Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。
不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。
zset的成员是唯一的,但分数(score)却可以重复。

2.什么是Redis持久化？Redis有哪几种持久化方式？优缺点是什么？
持久化就是把内存的数据写到磁盘中，防止服务宕机内存数据丢失
redis提供两种持久化方式：RDB和AOF

RDB：功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数，

AOF:每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作
aof写入保存：
WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件
SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。
比较:
1、aof文件比rdb更新频率高，优先使用aof还原数据。
2、aof比rdb更安全也更大
3、rdb性能比aof好
4、如果两个都配了优先加载AOF

3.redis的架构
1.主从复制

主从复制原理：

从服务器连接主服务器，发送SYNC命令；
主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；
主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；
从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；
主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；
从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；（从服务器初始化完成）
主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令（从服务器初始化完成后的操作）
主从复制优缺点：

优点：

支持主从复制，主机会自动将数据同步到从机，可以进行读写分离
为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成
Slave同样可以接受其它Slaves的连接和同步请求，这样可以有效的分载Master的同步压力。
Master Server是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求。
Slave Server同样是以非阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据
缺点：

Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。
主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。
Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。
2.哨兵模式

当主服务器中断服务后，可以将一个从服务器升级为主服务器，以便继续提供服务，但是这个过程需要人工手动来操作。 为此，Redis 2.8中提供了哨兵工具来实现自动化的系统监控和故障恢复功能。

哨兵的作用就是监控Redis系统的运行状况。它的功能包括以下两个。

（1）监控主服务器和从服务器是否正常运行。
（2）主服务器出现故障时自动将从服务器转换为主服务器。

哨兵的工作方式：

每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。
如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）
如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态
当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）
在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。
当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。
若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。
哨兵模式的优缺点

优点：

哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。
主从可以自动切换，系统更健壮，可用性更高。
缺点：

Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。
3.Redis-Cluster集群

redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。

Redis-Cluster采用无中心结构,它的特点如下：

所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。

节点的fail是通过集群中超过半数的节点检测失效时才生效。

客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。

工作方式：

在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。

为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。


4.redis如何做内存优化
  尽可能使用散列表，散列表使用的内存非常小，所以你应该近可能的将你的数据模型抽象到一个散列表中

5.Redis回收进程如何工作的
Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收

6.使用redis有哪些好处？
(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
(2)支持丰富数据类型，支持string，list，set，sorted set，hash
(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除

7.缓存雪崩
  redis挂掉，请求全部走数据库;对缓存数据设置相同的时间，导致某段时间内缓存失效，请求全部走数据库
  解决:redis挂掉:事发前：实现redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生；事发中：万一redis真的挂掉，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)；事发后，redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据
  缓存失效:在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。
8.缓存穿透
  缓存穿透是指查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。
  解决方法:1.由于请求的参数不合法，于是我们可以使用布隆过滤器或者拦截器提前拦下，不合法就不让这个请求到数据库;2.当我们从数据库找不到的时候，我们也将这个空对象设置到缓存中去，下次请求的时候，就可以从缓存红获取；3.这种情况我们一般会将空对象设置一个较短的过期时间
9.缓存和数据库双写一致
  什么叫不一致？
    缓存和数据库的值不一样.从理论上说，只要我们设置键的过期时间，我们就能保证缓存和数据库的数据最终是一致的。因为只要缓存数据过期，就会被删除。随后读的时候，因为缓存里没有数据，就可以直接查数据库，然后将数据库查出来的数据写入到缓存中
    先删除缓存，再更新数据库
  在高并发下表现不如意，在原子性被破坏时表现优异
  先更新数据库，再删除缓存(Cache Aside Pattern设计模式)
  在高并发下表现优异，在原子性被破坏时表现不如意

  采用延时双删策略:
  先删除缓存；
  再写数据库；
  休眠500毫秒；
  再次删除缓存

  异步更新缓存(基于订阅binlog的同步机制)
    MySQL binlog增量订阅消费+消息队列+增量数据更新到redis

10.Redis的高并发和快速原因
  1.redis是基于内存的，内存的读写速度非常快
  2.redis是单线程的，省去了很多上下文切换线程的时间；
  3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。
  为什么Redis是单线程的?
    因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。
    详细原因:
      1.不需要各种锁的性能消耗.Redis的数据结构并不全是简单的key-value，还有list，hash等复杂的结构，这些结构有可能会进行很细粒度的操作，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象，这些操作对象可能就需要加非常多的锁，导致同步的结果是同步开销大大增加,总之在单线程的情况下，就不用考虑各种锁的问题，不存在加锁释放锁的操作，没有因为可能出现死锁而导致性能消耗.
      2.单线程多进程集群方案:单线程的威力实际上非常强大，每核心效率也非常高，多线程自然是可以比单线程有更高的性能上限，但是今天的计算环境中，即使是单机多线程的上线也往往不能满足需要，需要进一步摸索的是多服务器集群化的方案，所以单线程、多进程的集群不失为一个时髦的解决方案。
      3.CPU消耗。采用单线程，避免不必要的上下问切换和竞争条件，也不存在多线程或多进程导致切换而消耗CPU。但是如果不让CPU成为瓶颈，或者不想服务器其他cpu闲置，可以考虑多起几个redis进程
  Redis单线程的优劣势
  优势：
  1.代码更清晰，处理逻辑简单
  2.不用考虑各种锁的问题，不存在加锁释放锁操作，没有因为出现死锁而导致的性能消耗
  3.不存在多进程或者多线程导致的切换而消耗CPU
  缺点:
  1.无法发挥多核CPU的性能，不过可以通过在单机开多个redis实例来完善
11.IO多路复用技术
  redis采用网络io多路复用技术来保证在多连接的时候，提高系统的吞吐量
  多路指的是多个socket连接，复用指的是复用一个线程。多路复用主要有三种技术：select、poll、epoll。epoll是最新的也是最好的多路复用技术。
12.出现并发设置Key的原因
  Redis是一种单线程机制的nosql数据库，基于key-value，数据可持久化落盘。由于单线程所以Redis本身并没有锁的概念，多个客户端连接并不存在竞争关系，但是利用jedis等客户端对Redis进行并发访问时会出现问题。
  解决方案:
    1.分布式锁+时间戳：主要用到的redis函数是setnx()；假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00<7:05），那就不做set操作了。
    2.利用消息队列
