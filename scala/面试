1.var，val和def三个关键字之间的区别？
  var是变量声明关键字，类似于Java中的变量，变量值可以更改，但是变量类型不能更改。
  val常量声明关键字。
  def 关键字用于创建方法（注意方法和函数的区别）
  还有一个lazy val（惰性val）声明，意思是当需要计算时才使用，避免重复计算
2.trait（特质）和abstract class（抽象类）的区别？
  （1）一个类只能集成一个抽象类，但是可以通过with关键字继承多个特质；
   (2)抽象类有带参数的构造函数，特质不行（如 trait t（i：Int）{} ，这种声明是错误的）
3.object和class的区别？
  object是类的单例对象，开发人员无需用new关键字实例化。如果对象的名称和类名相同，这个对象就是伴生对象
4.case class （样本类）是什么？
  样本类是一种不可变且可分解类的语法糖，这个语法糖的意思大概是在构建时，自动实现一些功能。样本类具有以下特性：
（1）自动添加与类名一致的构造函数（这个就是前面提到的伴生对象，通过apply方法实现），即构造对象时，不需要new；
（2）样本类中的参数默认添加val关键字，即参数不能修改；
（3）默认实现了toString，equals，hashcode，copy等方法；
（4）样本类可以通过==比较两个对象，并且不在构造方法中定义的属性不会用在比较上。
5.unapply 和apply方法的区别， 以及各自使用场景？
  提取器，它实现了构造器相反的效果，构造器从给定的参数创建一个对象，然而提取器却从对象中提取出构造该对象的参数，scala标准库预定义了一些提取器，如上面提到的样本类中，会自动创建一个伴生对象（包含apply和unapply方法）。为了成为一个提取器，unapply方法需要被伴生对象。apply方法是为了自动实现样本类的对象，无需new关键字。apply方法有点类似于java中的构造函数，接受构造参数变成一个对象。那么unapply方法就刚好相反，他是接受一个对象，从对象中提取出相应的值。
6.Scala类型系统中Nil, Null, None, Nothing四个类型的区别？
  Nil代表一个List空类型，等同List[Nothing]
  Null是一个trait（特质），是所以引用类型AnyRef的一个子类型，null是Null唯一的实例。
  None是Option monad的空标识
  Nothing也是一个trait（特质），是所有类型Any（包括值类型和引用类型）的子类型，它不在有子类型，它也没有实例，实际上为了一个方法抛出异常，通常会设置一个默认返回类型。
7.Unit类型是什么？
  Unit代表没有任何意义的值类型，类似于java中的void类型
8.call-by-value和call-by-name求值策略的区别？
//声明第一个函数
def func(): Int = {
println("computing stuff....")
42 // return something
}
//声明第二个函数，scala默认的求值就是call-by-value
def callByValue(x: Int) = {
println("1st x: " + x)
println("2nd x: " + x)
}
//声明第三个函数，用=>表示call-by-name求值
def callByName(x: => Int) = {
println("1st x: " + x)
println("2nd x: " + x)
}

//开始调用

//call-by-value求值
callByValue(func())
//输出结果
//computing stuff....
//1st x: 42
//2nd x: 42

//call-by-name求值
callByName(func())
//输出结果
//computing stuff....
//1st x: 42
//computing stuff....
//2nd x: 42
9.Option类型的定义和使用场景？
  在Java中，null是一个关键字，不是一个对象，当开发者希望返回一个空对象时，却返回了一个关键字，为了解决这个问题，Scala建议开发者返回值是空值时，使用Option类型，在Scala中null是Null的唯一对象，会引起异常，Option则可以避免。Option有两个子类型，Some和None（空值）
10.解释隐示参数的优先权
在Scala中implicit的功能很强大。当编译器寻找implicits时，如果不注意隐式参数的优先权，可能会引起意外的错误。因此编译器会按顺序查找隐式关键字。顺序如下：
（1）当前类声明的implicits ；
（2）导入包中的 implicits；
（3）外部域（声明在外部域的implicts）；
（4）inheritance
（5）package object
（6）implicit scope like companion objects
11.柯里化函数
  有多个参数列表 的函数就是柯里化函数，所谓的参数列表就是使用小括号括起来的函数参数列表
  scala> def sum(x:Int)(y:Int)=x+y
sum: (x: Int)(y: Int)Int

scala> val second = sum(1)_
second: Int => Int = <function1>

scala> second(2)
res1: Int = 3
12.什么是尾递归？
正常递归，每一次递归步骤，需要保存信息到堆栈里面，当递归步骤很多时，导致堆栈溢出。
尾递归就是为了解决上述问题，在尾递归中所有的计算都是在递归之前调用，
编译器可以利用这个属性避免堆栈错误，尾递归的调用可以使信息不插入堆栈，从而优化尾递归。
13.什么是高阶函数？
  高阶函数指能接受或者返回其他函数的函数，scala中的filter map flatMap函数都能接受其他函数作为参数。
